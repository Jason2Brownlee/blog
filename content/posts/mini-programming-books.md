---
date: '2025-12-10T08:46:50+11:00'
title: 'Programming Mini-Books'
---

I loved learning programming and writing code as a student.

The nuts and bolts stuff. The learning curves.

There was a thrill in unlocking a new feature, a new language, a new library, in building a thing.

I was thinking about re-capturing some of that.

One idea I had was to write a series of mini-books on programming, e.g. 6"x9" books, with about 100 pages.

There are many ways this could go, but I was thinking of selecting 5-10 languages and writing an jump-start for each.

It would be an excuse to brush up on each language and attempt to unify a pedagogical method for programming-jump-start across the languages.

What languages?

Perhaps those I've used the most over the years/those that remain the most popular:

- C
- C++
- Java
- C#
- Fortran
- Python
- Ruby
- PHP
- Javascript
- Go
- Rust

Hmmm, just listing it out makes this project sound more fun.

Although the books would be written for an audience (e.g. someone who can program, just not in the target language), I'd be writing them for myself, not for profit. Meaning, sold at cost, code+tutorials free on a website, etc.

WHY?

**The world does not need another programming language jump-start book!!!**

I know. I know. It's for me. For fun. Journey, not destination. Hobby. Nostalgia.

The fun would be in building each book, remembering how to use the language, deciding what to include/exclude, developing instructive examples, all that.

It would not take that long, a book per month, max. Probably the main content could be done a week or two.

The real challenge would be NOT leaning on an LLM and instead, reading the language spec/API and thinking for myself :)

What's the structure across the books?

Something like 10 sections of 10 pages (developed with gpt5.1, after some back and forth):

---

1. Orientation / Overview: What the language is, why it exists, its design goals, paradigms, use cases, strengths, and tradeoffs.
2. Syntax in 20 Minutes: A quick “phrasebook”: variables, types, operators, conditionals, loops, functions, modules, comments, basic I/O.
3. Type System & Data Model: How the language thinks: primitives, composite types, mutability, static vs dynamic, value vs reference, memory model.
4. Functions, Classes, and Abstractions: How programs are structured: functions, closures, classes/structs, interfaces, generics, modules/namespaces.
5. Idioms & Common Patterns: How real developers write it: key language idioms and cultural norms unique to the ecosystem.
6. Tooling, Build, and Project Structure: Package managers, build tools, linters/formatters, testing, debugging, typical project layout.
7. Memory, Performance, and Concurrency Model: Runtime behavior: garbage collection or manual memory, concurrency style, performance characteristics.
8. Error Handling Philosophy: How correctness is managed: exceptions, error values, option/result types, panics, best practices.
9. Standard Library Tour: Essential “batteries included”: strings, collections, file I/O, networking, JSON, date/time, concurrency helpers.
10. Capstone Example Project: A small but realistic program showing idiomatic usage, testing, structure, error handling, and packaging.

---

Sounds fun!

Have I purged this idea? Am I going to do it? No idea.

Remember, everything looks fun on the surface. Is it still fun two weeks into the grind on the third book in the series? Maybe.